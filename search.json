[{"categories":["AI应用"],"content":" 内容简介 介绍MCP和LLM之间的协作细节，讲解LLM是如何利用MCP服务来扩展自己的边际能力的。 在用go做了几个MCP的Demo服务后，又对MCP的架构和协议细节进行了深入地学习，对MCP的理解深刻了很多。但是在开发过程中还是有两个关键的问题未得到解答： cline插件、我的MCP服务、大模型这三者之间的调用流程是怎样的？ 大模型是在什么时候确定使用哪些MCP服务的呢？ 这里需要注意下，我使用的是vscode的cline插件，所以这里拿cline举例，但是其实客户端也可以是cursor、cherry studio等其他客户端。 在 MCP 官网为我们提供了一个解释： 客户端将你的问题发送给 Claude Claude 分析可用的工具，并决定使用哪一个或多个 客户端通过 MCP Server 执行所选的工具 工具的执行结果被送回给 Claude Claude 结合执行结果生成回答 回应最终展示给用户 从以上的解释可以看出，大模型和MCP服务之间的调用过程是分两步完成的： 由 LLM 确定使用哪些 MCP Server 执行对应的 MCP Server 并对执行结果进行重新处理 所以 MCP Server 是由大模型主动选择并调用的。但是大模型具体又是如何确定该使用哪些工具呢？从 MCP 官方提供的 pyhton client example 中可以得到答案： async def start(self) -\u003e None: \"\"\"Main chat session handler.\"\"\" try: for server in self.servers: try: await server.initialize() except Exception as e: logging.error(f\"Failed to initialize server: {e}\") await self.cleanup_servers() return all_tools = [] for server in self.servers: tools = await server.list_tools() all_tools.extend(tools) tools_description = \"\\n\".join([tool.format_for_llm() for tool in all_tools]) system_message = ( \"You are a helpful assistant with access to these tools:\\n\\n\" f\"{tools_description}\\n\" \"Choose the appropriate tool based on the user's question. \" \"If no tool is needed, reply directly.\\n\\n\" \"IMPORTANT: When you need to use a tool, you must ONLY respond with \" \"the exact JSON object format below, nothing else:\\n\" \"{\\n\" ' \"tool\": \"tool-name\",\\n' ' \"arguments\": {\\n' ' \"argument-name\": \"value\"\\n' \" }\\n\" \"}\\n\\n\" \"After receiving a tool's response:\\n\" \"1. Transform the raw data into a natural, conversational response\\n\" \"2. Keep responses concise but informative\\n\" \"3. Focus on the most relevant information\\n\" \"4. Use appropriate context from the user's question\\n\" \"5. Avoid simply repeating the raw data\\n\\n\" \"Please use only the tools that are explicitly defined above.\" ) messages = [{\"role\": \"system\", \"content\": system_message}] while True: try: user_input = input(\"You: \").strip().lower() if user_input in [\"quit\", \"exit\"]: logging.info(\"\\nExiting...\") break messages.append({\"role\": \"user\", \"content\": user_input}) llm_response = self.llm_client.get_response(messages) logging.info(\"\\nAssistant: %s\", llm_response) result = await self.process_llm_response(llm_response) if result != llm_response: messages.append({\"role\": \"assistant\", \"content\": llm_response}) messages.append({\"role\": \"system\", \"content\": result}) final_response = self.llm_client.get_response(messages) logging.info(\"\\nFinal response: %s\", final_response) messages.append( {\"role\": \"assistant\", \"content\": final_response} ) else: messages.append({\"role\": \"assistant\", \"content\": llm_response}) except KeyboardInterrupt: logging.info(\"\\nExiting...\") break finally: await self.cleanup_servers() ... # 省略其他代码 从代码可以看出，在和大模型进行交互前，将所有工具的结构化描述放到tools_description中，再添加到system_message中，然后把system_message和用户消息一起发送给模型。当模型分析用户请求后，它会决定是否需要调用工具： 无需工具时：模型直接生成自然语言回复。 需要工具时：模型输出结构化 JSON 格式的工具调用请求。 当回复中包含结构化 JSON 格式的工具调用请求，则客户端会根据这个 json 代码调用对应的工具。以上两点可以在get_response、process_llm_response中看到实现，代码逻辑非常简单： def get_response(self, messages: list[dict[str, str]]) -\u003e str: \"\"\"Get a response from the LLM. Args: messages: A list of message dictionaries. Returns: The LLM's response as a string. Raises: httpx.RequestError: If the request to the LLM fails. \"\"\" url = \"https://api.groq.com/openai/v1/chat/completions\" headers = { \"Content-Type\": \"application/json\", \"Authorization\": f\"Bearer {self.api_key}\", } payload = { \"messages\": messages, \"model\": \"llama-3.2-90b-vision-preview\", \"temperature\": 0.7, \"max_tokens\": 4096, \"top_p\": 1, \"stream\": False, \"stop\": None, } try: with httpx.Client() as client: response = client.post(url, headers=headers, json=payload) response.raise_for_status() data = response.json() return data[\"choices\"][0][\"message\"][\"content\"] except httpx.RequestError as e: error_message = f\"Error getting LLM response: {str(e)}\" logging.error(error_message) if isinstance(e, httpx.HTTPStatusError): status_code = e.response.status_code logging.error(f\"Status code: {status_code}\") logging.error","date":"2025-04-18","objectID":"/posts/ai/f6ee174/:0:0","tags":["MCP","AI"],"title":"MCP和LLM的调用细节","uri":"/posts/ai/f6ee174/"},{"categories":["AI应用"],"content":" 内容简介 介绍 MCP 的架构和协议实现。 随着最近 MCP 在各类文章和评论区中逐渐活跃，我也找了几篇 MCP 相关的文章进行阅读学习，但是我发现这些文章都大同小异，没有让我真正深入理解MCP。我也跟着一些文章用 go 语言实现了几个 MCP 的Demo服务，但是对 MCP 依然一知半解，所以感觉还是得系统深入的学习并总结下。 ","date":"2025-04-16","objectID":"/posts/ai/130309a/:0:0","tags":["MCP","AI"],"title":"MCP架构和协议解析","uri":"/posts/ai/130309a/"},{"categories":["AI应用"],"content":"MCP是什么 MCP 是一种开放协议，用于标准化应用程序如何为 LLM 提供上下文。可以将 MCP 视为 AI 应用程序的 USB-C 端口。正如 USB-C 提供了一种标准化的方式来将设备连接到各种外围设备和配件，MCP 也提供了一种标准化的方式，用于将 AI 模型连接到不同的数据源和工具。 从上面这段官方的介绍来看，MCP 的目标是创建一个通用标准，使 AI 应用程序的开发和集成变得更加简单和统一。这里我引用一张流传很广的图片来帮助理解： ","date":"2025-04-16","objectID":"/posts/ai/130309a/:1:0","tags":["MCP","AI"],"title":"MCP架构和协议解析","uri":"/posts/ai/130309a/"},{"categories":["AI应用"],"content":"为什么要用MCP 我们使用LLM的方式基本都是在客户端将问题发给大模型，然后大模型返回结果。面对一些特定的问题，还需要人工从数据库中筛选或者使用工具检索可能需要的信息，手动的粘贴到 prompt 中。但是随着问题一旦变得复杂，手动的粘贴信息到 prompt 中，就会非常麻烦。虽然许多 LLM 平台引入了 function call 功能。这一机制允许模型在需要时调用预定义的函数来获取数据或执行操作。但是 function call 有一个很明显的局限性，那就是不同 LLM 平台的 function call API 实现差异较大。开发者在切换模型时需要重写代码，适配成本很高。下面是一些 LLM 平台 function call API 的实现示例： OpenAI: { \"index\": 0, \"message\": { \"role\": \"assistant\", \"content\": null, \"tool_calls\": [ { \"name\": \"get_current_stock_price\", \"arguments\": \"{\\n \\\"company\\\": \\\"Apple Inc.\\\",\\n \\\"format\\\": \\\"USD\\\"\\n}\" } ] }, \"finish_reason\": \"tool_calls\" } Claude: { \"role\": \"assistant\", \"content\": [ { \"type\": \"text\", \"text\": \"\u003cthinking\u003eTo answer this question, I will: …\u003c/thinking\u003e\" }, { \"type\": \"tool_use\", \"id\": \"toolu_01A09q90qw90lq917835lq9\", \"name\": \"get_current_stock_price\", \"input\": {\"company\": \"Apple Inc.\", \"format\": \"USD\"} } ] } Gemini: { \"functionCall\": { \"name\": \"get_current_stock_price\", \"args\": { \"company\": \"Apple Inc.\", \"format\": \"USD\" } } } 从上面的示例也可以看到，各家 LLM 平台的 function call API有各自的调用格式。而 MCP 的出现统一了 AI 模型连接外部不同数据源和工具的标准，这也让各种各样的服务都开发了自己的 MCP 服务接口，进一步促进了 MCP 生态的开发和推广。 ","date":"2025-04-16","objectID":"/posts/ai/130309a/:2:0","tags":["MCP","AI"],"title":"MCP架构和协议解析","uri":"/posts/ai/130309a/"},{"categories":["AI应用"],"content":"MCP架构 ","date":"2025-04-16","objectID":"/posts/ai/130309a/:3:0","tags":["MCP","AI"],"title":"MCP架构和协议解析","uri":"/posts/ai/130309a/"},{"categories":["AI应用"],"content":"核心架构解析 这里先引入官方的架构图： MCP 由三个核心组件构成：Host、Client 和 Server。让我们通过一个实际场景来理解这些组件如何协同工作：假设你正在使用vscode的cline插件询问：“我的main.go文件里面实现了什么功能？” Host：cline 作为 Host，负责接收你的提问并与你在cline中配置的模型交互。 Client：当大模型分析问题后发现需要读取你的main.go文件，Host 中内置的 MCP Client 会被激活。这个 Client 负责与适当的 MCP Server 建立连接。 Server：MCP Server 是一个特殊的应用程序，它负责与外部数据源或工具进行交互。在本例中，会使用 filesystem 这个 MCP Server 来读取 main.go 文件。 整个流程大致如下图所示： graph LR subgraph 应用程序宿主进程 H[主机] C1[客户端 1] C2[客户端 2] C3[客户端 3] H --\u003e C1 H --\u003e C2 H --\u003e C3 end subgraph 本地机器 S1[服务器 1 文件和 Git] S2[服务器 2 数据库] R1[(本地 资源 A)] R2[(本地 资源 B)] C1 --\u003e S1 C2 --\u003e S2 S1 \u003c--\u003e R1 S2 \u003c--\u003e R2 end subgraph 互联网 S3[服务器 3 外部 API] R3[(远程 资源 C)] C3 --\u003e S3 S3 \u003c--\u003e R3 end graph LR subgraph 应用程序宿主进程 H[主机] C1[客户端 1] C2[客户端 2] C3[客户端 3] H --\u003e C1 H --\u003e C2 H --\u003e C3 end subgraph 本地机器 S1[服务器 1 文件和 Git] S2[服务器 2 数据库] R1[(本地 资源 A)] R2[(本地 资源 B)] C1 --\u003e S1 C2 --\u003e S2 S1 \u003c--\u003e R1 S2 \u003c--\u003e R2 end subgraph 互联网 S3[服务器 3 外部 API] R3[(远程 资源 C)] C3 --\u003e S3 S3 \u003c--\u003e R3 end也就是说在MCP的工程实践中，Host和Client是集成在一起的，至于什么时候需要用到MCP Server，用哪一个MCP Server，这由大模型决定。而MCP server的功能由开发者根据需要去做不同的实现。 这种架构设计使得大模型可以在不同场景下灵活调用各种工具和数据源，而开发者只需专注于开发对应的 MCP Server，无需关心 Host 和 Client 的实现细节。 ","date":"2025-04-16","objectID":"/posts/ai/130309a/:3:1","tags":["MCP","AI"],"title":"MCP架构和协议解析","uri":"/posts/ai/130309a/"},{"categories":["AI应用"],"content":"组件详情 主机 创建和管理多个客户端实例 控制客户端连接权限和生命周期 执行安全策略和同意要求 处理用户授权决策 协调 AI/LLM 集成和采样 管理跨客户端的上下文聚合 客户端 每个客户端由宿主创建，并维护一个隔离的服务器连接： 为每个服务器建立一个有状态会话 处理协议协商和能力交换 双向路由协议消息 管理订阅和通知 维护服务器之间的安全边界 一个宿主应用程序创建和管理多个客户端，每个客户端与特定的服务器有 1:1 的关系。 服务器 服务器提供专门的上下文和功能: 通过 MCP 原语公开资源、工具和提示 独立运行，具有专注的职责 通过客户端接口请求采样 必须尊重安全约束 可以是本地进程或远程服务 ","date":"2025-04-16","objectID":"/posts/ai/130309a/:3:2","tags":["MCP","AI"],"title":"MCP架构和协议解析","uri":"/posts/ai/130309a/"},{"categories":["AI应用"],"content":"协议基础 MCP 中的所有消息必须遵循 JSON-RPC 2.0 规范。协议定义了三种类型的消息：请求、响应和通知。 ","date":"2025-04-16","objectID":"/posts/ai/130309a/:4:0","tags":["MCP","AI"],"title":"MCP架构和协议解析","uri":"/posts/ai/130309a/"},{"categories":["AI应用"],"content":"请求 双向消息，可以从客户端发送到服务器，也可以反向发送 必须包含字符串或整数类型的 ID ID 不能为 null 在同一会话中，请求方不能重复使用相同的 ID 可以包含可选的参数对象 请求示例： { \"jsonrpc\": \"2.0\", \"id\": \"string | number\", \"method\": \"string\", \"param?\": { \"key\": \"value\" } } ","date":"2025-04-16","objectID":"/posts/ai/130309a/:4:1","tags":["MCP","AI"],"title":"MCP架构和协议解析","uri":"/posts/ai/130309a/"},{"categories":["AI应用"],"content":"响应 作为对请求的回复而发送。 必须包含与对应请求相同的 ID 必须设置 result 或 error 其中之一，不能同时设置 错误码必须是整数 可以包含可选的结果数据 响应示例： { \"jsonrpc\": \"2.0\", \"id\": \"string | number\", \"result?\": { \"[key: string]\": \"unknown\" }, \"error?\": { \"code\": \"number\", \"message\": \"string\", \"data?\": \"unknown\" } } ","date":"2025-04-16","objectID":"/posts/ai/130309a/:4:2","tags":["MCP","AI"],"title":"MCP架构和协议解析","uri":"/posts/ai/130309a/"},{"categories":["AI应用"],"content":"通知 不需要响应的单向消息，可以从客户端发送到服务器，也可以反向发送。 不能包含 ID 字段 用于状态更新和事件通知 可以包含可选的参数对象 减少通信开销，支持异步操作 通知示例： { \"jsonrpc\": \"2.0\", \"method\": \"string\", \"params?\": { \"[key: string]\": \"unknown\" } } ","date":"2025-04-16","objectID":"/posts/ai/130309a/:4:3","tags":["MCP","AI"],"title":"MCP架构和协议解析","uri":"/posts/ai/130309a/"},{"categories":["AI应用"],"content":"生命周期 MCP 为客户端-服务器连接定义了严格的生命周期，确保正确的能力协商和状态管理。主要包含三个阶段： 初始化：能力协商和协议版本协商 操作：通过协议正常交换信息 关闭：安全终止连接 生命周期时序图： sequenceDiagram participant Client participant Server Note over Client,Server: 初始化阶段 activate Client Client-\u003e\u003e+Server: 初始化请求 Server--\u003e\u003eClient: 初始化响应 Client--)Server: 已初始化通知 Note over Client,Server: 操作阶段 rect rgb(200, 220, 250) note over Client,Server: 正常协议操作 end Note over Client,Server: 关闭 Client--)Server: 断开连接 deactivate Server Note over Client,Server: 连接已关闭 sequenceDiagram participant Client participant Server Note over Client,Server: 初始化阶段 activate Client Client-\u003e\u003e+Server: 初始化请求 Server--\u003e\u003eClient: 初始化响应 Client--)Server: 已初始化通知 Note over Client,Server: 操作阶段 rect rgb(200, 220, 250) note over Client,Server: 正常协议操作 end Note over Client,Server: 关闭 Client--)Server: 断开连接 deactivate Server Note over Client,Server: 连接已关闭","date":"2025-04-16","objectID":"/posts/ai/130309a/:5:0","tags":["MCP","AI"],"title":"MCP架构和协议解析","uri":"/posts/ai/130309a/"},{"categories":["AI应用"],"content":"初始化阶段 初始化阶段是客户端和服务器之间的第一次交互。在此阶段，双方： 建立协议版本兼容性 交换和协商能力 共享实现细节 其中的核心是版本协商和能力协商。 sequenceDiagram participant Host participant Client participant Server Host-\u003e\u003e+Client: 初始化客户端 Client-\u003e\u003e+Server: 用能力初始化会话 Server--\u003e\u003eClient: 响应支持的能力 Note over Host,Server: 具有协商功能的活动会话 loop 客户端请求 Host-\u003e\u003eClient: 用户或模型发起的操作 Client-\u003e\u003eServer: 请求（工具/资源） Server--\u003e\u003eClient: 响应 Client--\u003e\u003eHost: 更新UI或响应模型 end loop 服务器请求 Server-\u003e\u003eClient: 请求（采样） Client-\u003e\u003eHost: 转发到AI Host--\u003e\u003eClient: AI响应 Client--\u003e\u003eServer: 响应 end loop 通知 Server--)Client: 资源更新 Client--)Server: 状态变更 end Host-\u003e\u003eClient: 终止 Client-\u003e\u003e-Server: 结束会话 deactivate Server sequenceDiagram participant Host participant Client participant Server Host-\u003e\u003e+Client: 初始化客户端 Client-\u003e\u003e+Server: 用能力初始化会话 Server--\u003e\u003eClient: 响应支持的能力 Note over Host,Server: 具有协商功能的活动会话 loop 客户端请求 Host-\u003e\u003eClient: 用户或模型发起的操作 Client-\u003e\u003eServer: 请求（工具/资源） Server--\u003e\u003eClient: 响应 Client--\u003e\u003eHost: 更新UI或响应模型 end loop 服务器请求 Server-\u003e\u003eClient: 请求（采样） Client-\u003e\u003eHost: 转发到AI Host--\u003e\u003eClient: AI响应 Client--\u003e\u003eServer: 响应 end loop 通知 Server--)Client: 资源更新 Client--)Server: 状态变更 end Host-\u003e\u003eClient: 终止 Client-\u003e\u003e-Server: 结束会话 deactivate Server","date":"2025-04-16","objectID":"/posts/ai/130309a/:5:1","tags":["MCP","AI"],"title":"MCP架构和协议解析","uri":"/posts/ai/130309a/"},{"categories":["AI应用"],"content":"操作阶段 在操作阶段，客户端和服务器根据协商的能力交换消息。 遵守协商的协议版本 仅使用成功协商的能力 ","date":"2025-04-16","objectID":"/posts/ai/130309a/:5:2","tags":["MCP","AI"],"title":"MCP架构和协议解析","uri":"/posts/ai/130309a/"},{"categories":["AI应用"],"content":"关闭阶段 在关闭阶段，连接被优雅地终止。 客户端发送断开连接通知 服务器关闭连接 清理相关资源 ","date":"2025-04-16","objectID":"/posts/ai/130309a/:5:3","tags":["MCP","AI"],"title":"MCP架构和协议解析","uri":"/posts/ai/130309a/"},{"categories":["AI应用"],"content":"传输机制 MCP 目前定义了两种标准的客户端-服务器通信传输机制：stdio（标准输入输出）和基于 SSE 的 HTTP。客户端应尽可能支持 stdio。此外，客户端和服务器也可以以可插拔的方式实现自定义传输机制。 ","date":"2025-04-16","objectID":"/posts/ai/130309a/:6:0","tags":["MCP","AI"],"title":"MCP架构和协议解析","uri":"/posts/ai/130309a/"},{"categories":["AI应用"],"content":"标准输入输出（stdio） 在 stdio 传输中： 客户端将 MCP 服务器启动为子进程。 服务器在其标准输入（stdin）上接收 JSON-RPC 消息，并将响应写入其标准输出（stdout）。 消息由换行符分隔，并且不得包含嵌入的换行符。 服务器可以为日志记录目的向其标准错误（stderr）写入 UTF-8 字符串。客户端可以捕获、转发或忽略此日志记录。 服务器不得向其 stdout 写入任何不是有效 MCP 消息的内容。 客户端不得向服务器的 stdin 写入任何不是有效 MCP 消息的内容。 sequenceDiagram participant Client participant Server Process Client-\u003e\u003e+Server Process: 启动子进程 loop 消息交换 Client-\u003e\u003eServer Process: 写入 stdin Server Process-\u003e\u003eClient: 写入 stdout Server Process--)Client: 可选的 stderr 日志 end Client-\u003e\u003eServer Process: 关闭 stdin，终止子进程 deactivate Server Process sequenceDiagram participant Client participant Server Process Client-\u003e\u003e+Server Process: 启动子进程 loop 消息交换 Client-\u003e\u003eServer Process: 写入 stdin Server Process-\u003e\u003eClient: 写入 stdout Server Process--)Client: 可选的 stderr 日志 end Client-\u003e\u003eServer Process: 关闭 stdin，终止子进程 deactivate Server Process","date":"2025-04-16","objectID":"/posts/ai/130309a/:6:1","tags":["MCP","AI"],"title":"MCP架构和协议解析","uri":"/posts/ai/130309a/"},{"categories":["AI应用"],"content":"基于 SSE 的 HTTP 在 SSE 传输中，服务器作为独立进程运行，可以处理多个客户端连接。服务器必须提供两个端点： 一个 SSE 端点，供客户端建立连接并接收来自服务器的消息 一个常规的 HTTP POST 端点，供客户端向服务器发送消息 当客户端连接时，服务器必须发送一个包含 URI 的 endpoint 事件，客户端用于发送消息。所有后续客户端消息必须作为 HTTP POST 请求发送到此端点。服务器消息作为 SSE message 事件发送，消息内容在事件数据中编码为 JSON。 sequenceDiagram participant Client participant Server Client-\u003e\u003eServer: 打开 SSE 连接 Server-\u003e\u003eClient: endpoint 事件 loop 消息交换 Client-\u003e\u003eServer: HTTP POST 消息 Server-\u003e\u003eClient: SSE message 事件 end Client-\u003e\u003eServer: 关闭 SSE 连接 sequenceDiagram participant Client participant Server Client-\u003e\u003eServer: 打开 SSE 连接 Server-\u003e\u003eClient: endpoint 事件 loop 消息交换 Client-\u003e\u003eServer: HTTP POST 消息 Server-\u003e\u003eClient: SSE message 事件 end Client-\u003e\u003eServer: 关闭 SSE 连接","date":"2025-04-16","objectID":"/posts/ai/130309a/:6:2","tags":["MCP","AI"],"title":"MCP架构和协议解析","uri":"/posts/ai/130309a/"},{"categories":["AI应用"],"content":"自定义传输 客户端和服务器可以以可插拔的方式实现自定义传输机制。该协议与传输无关，可以在任何支持双向消息交换的通信通道上实现。选择支持自定义传输的实施者必须确保他们保留 MCP 定义的 JSON-RPC 消息格式和生命周期要求。自定义传输应该记录其特定的连接建立和消息交换模式，以帮助互操作性。 ","date":"2025-04-16","objectID":"/posts/ai/130309a/:6:3","tags":["MCP","AI"],"title":"MCP架构和协议解析","uri":"/posts/ai/130309a/"},{"categories":["devops"],"content":" 内容简介 详细介绍nacos集群搭建步骤和过程。 ","date":"2025-04-14","objectID":"/posts/devops/338be2a/:0:0","tags":["nacos"],"title":"nacos集群搭建","uri":"/posts/devops/338be2a/"},{"categories":["devops"],"content":"环境准备 本文采用的Linux系统为 Rocky Linux release 8.10 版本，nacos版本为 2.2.3，数据库使用mysql的 5.7.43 版本。 服务器 节点功能 软件包版本 10.0.0.10 nacos节点1 2.2.3 10.0.0.11 nacos节点2 2.2.3 10.0.0.12 nacos节点3 2.2.3 10.0.0.13 mysql数据库 5.7.43 在10.0.0.10、10.0.0.11、10.0.0.12服务器安装java1.8： # 安装java1.8 yum list java* --showduplicate | sort -r yum install -y java-1.8.0-openjdk-devel.x86_64 java -version #查看java版本 在10.0.0.13服务器安装mysql： # 安装mysql 5.7.43 rpm -ivh https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm sed -i 's/gpgcheck=1/gpgcheck=0/' /etc/yum.repos.d/mysql-community.repo yum -y install mysql-community-server systemctl enable --now mysqld password=`sed -n '/temporary password/s/.*root@localhost: \\(.*\\)/\\1/p' /var/log/mysqld.log` mysql -uroot -p\"$password\" --connect-expired-password -e\"set global validate_password_policy=0;\" mysql -uroot -p\"$password\" --connect-expired-password -e\"set global validate_password_length=6;\" mysql -uroot -p\"$password\" --connect-expired-password -e\"alter user 'root'@'localhost' identified by '123456';\" 这里将mysql密码策略设置为简单，仅仅为了演示方便，生产不建议这么做。同时生产中nacos一般用作注册中心和配置中心，所以nacos用的数据库最好使用集群方式。 ","date":"2025-04-14","objectID":"/posts/devops/338be2a/:1:0","tags":["nacos"],"title":"nacos集群搭建","uri":"/posts/devops/338be2a/"},{"categories":["devops"],"content":"安装nacos集群 ","date":"2025-04-14","objectID":"/posts/devops/338be2a/:2:0","tags":["nacos"],"title":"nacos集群搭建","uri":"/posts/devops/338be2a/"},{"categories":["devops"],"content":"安装nacos 官网下载安装包，然后上传到10.0.0.10、10.0.0.11、10.0.0.12服务器。在这三台服务器上执行： # 将nacos解压到/usr/local/目录下 tar xf nacos-server-2.2.3.tar.gz -C /usr/local/ 在10.0.0.13服务器上配置nacos使用的mysql数据库： # 提前将nacos数据sql文件复制到本机的/tmp目录下，sql文件在nacos安装目录的conf目录下：/usr/local/nacos/conf/ mysql -uroot -p123456 create database nacos_config default character set utf8; create user 'nacos'@'%' identified by '123456'; #演示用，生产请保证密码复杂度 grant all privileges on nacos_config.* to 'nacos'@'%'; flush privileges; use nacos_config; source /tmp/mysql-schema.sql; #执行nacos数据库脚本 show tables; #查看创建的表 ","date":"2025-04-14","objectID":"/posts/devops/338be2a/:2:1","tags":["nacos"],"title":"nacos集群搭建","uri":"/posts/devops/338be2a/"},{"categories":["devops"],"content":"配置并启动nacos vim /usr/local/nacos/conf/application.properties spring.sql.init.platform=mysql db.num=1 db.url.0=jdbc:mysql://10.0.0.13:3306/nacos_config?characterEncoding=utf8\u0026connectTimeout=1000\u0026socketTimeout=3000\u0026autoReconnect=true\u0026useUnicode=true\u0026useSSL=false\u0026serverTimezone=UTC db.user.0=nacos db.password.0=123456 management.endpoints.web.exposure.include=prometheus #开启prometheus监控 nacos.core.auth.enabled=true #开启权限认证 nacos.core.auth.system.type=nacos nacos.core.auth.plugin.nacos.token.secret.key=${自定义，保证所有节点一致} nacos.core.auth.server.identity.key=${自定义，保证所有节点一致} nacos.core.auth.server.identity.value=${自定义，保证所有节点一致} cd /usr/local/nacos/conf/ cp -a cluster.conf.example cluster.conf vim cluster.conf 10.0.0.10:8848 10.0.0.11:8848 10.0.0.12:8848 # 将配置文件复制到另外两个主机 scp /usr/local/nacos/conf/application.properties 10.0.0.11:/usr/local/nacos/conf/ scp /usr/local/nacos/conf/cluster.conf 10.0.0.11:/usr/local/nacos/conf/ scp /usr/local/nacos/conf/application.properties 10.0.0.12:/usr/local/nacos/conf/ scp /usr/local/nacos/conf/cluster.conf 10.0.0.11:/usr/local/nacos/conf/ # 依次启动三台服务器上的nacos sh /usr/local/nacos/bin/startup.sh tail -f /usr/local/nacos/logs/start.out #查看启动日志，如果日志最后显示如下，则成功 ... 2023-08-19 15:55:33,901 INFO Nacos started successfully in cluster mode. use external storage ","date":"2025-04-14","objectID":"/posts/devops/338be2a/:2:2","tags":["nacos"],"title":"nacos集群搭建","uri":"/posts/devops/338be2a/"},{"categories":["devops"],"content":"nacos集群访问 使用nginx作为负载均衡来访问nacos集群，nginx配置如下： upstream nacos-cluster { server 10.0.0.9:8848; server 10.0.0.10:8848; server 10.0.0.12:8848; } server { listen 80; server_name www.nacos.com; #access_log /var/log/nginx/host.access.log main; location / { #root html; #index index.html index.htm; proxy_pass http://nacos-cluster/nacos/; #'/'斜杠不能去掉 } } 正如上面所说，nacos用作注册中心和配置中心，是非常重要的服务，不仅数据库要使用集群来避免单点故障，用来反向代理nacos集群的nginx也需要高可用部署。推荐使用nginx+keepalived来实现，不过这里就不再演示了。 参考资料： Nacos官网 ","date":"2025-04-14","objectID":"/posts/devops/338be2a/:3:0","tags":["nacos"],"title":"nacos集群搭建","uri":"/posts/devops/338be2a/"},{"categories":["建站笔记"],"content":" 内容简介 基于主题在 Hugo 博客中添加一个新的页面。这里说的页面不是指 Hugo 利用 markdown 文件生成的页面，而是我们自己手动创建的 html 页面。 我想添加一个网站合集页面，这个页面分类展示各类有用的网站。但是 FixIt 主题中并没有提供这个页面实现，所以只能自己动手写一个。 ","date":"2025-04-12","objectID":"/posts/hugo-fixit/3c94d6e/:0:0","tags":["建站笔记"],"title":"Hugo 自定义页面","uri":"/posts/hugo-fixit/3c94d6e/"},{"categories":["建站笔记"],"content":"前置知识 添加自定义页面其实并不复杂，但是需要了解一些 HTML、CSS、JavaScript 的基础，还有 Hugo 中函数的用法。其次不太推荐使用类似 Vue 这样的 JS 框架，因为 Hugo 的页面使用了大量的 golang 模板语法，就是你在主题文件中看到的{{}}语法，而 Vue 中也有到这个语法，这可能会在无意中给你的开发造成障碍，甚至在解析模板时出错。 ","date":"2025-04-12","objectID":"/posts/hugo-fixit/3c94d6e/:1:0","tags":["建站笔记"],"title":"Hugo 自定义页面","uri":"/posts/hugo-fixit/3c94d6e/"},{"categories":["建站笔记"],"content":"添加自定义页面 作为一个前端小白，自己从头实现一个新的页面，有点难度。这里我参考了 FixIt 主题友链页面的实现方式，友链页面添加可以参考 Fixit-主题美化 一文。 ","date":"2025-04-12","objectID":"/posts/hugo-fixit/3c94d6e/:2:0","tags":["建站笔记"],"title":"Hugo 自定义页面","uri":"/posts/hugo-fixit/3c94d6e/"},{"categories":["建站笔记"],"content":"定义站点页面的内容模板 在archetypes目录下创建websites.md，内容参考archetypes/friends.md。 --- title: {{ replace .TranslationBaseName \"-\" \" \" | title }} subtitle: layout: websites date: {{ .Date }} description: \"{{ .Site.Params.author.name }}'s websites\" keywords: - 'Hugo FixIt' - 'websites template' - 站点导航 comment: false --- \u003c!-- The `websites.yml` file placed in the `yourProject/data/` directory will be loaded automatically here. --\u003e --- \u003c!-- You can define additional content below for this page. --\u003e ## Base info - nickname: Lruihao - avatar: https://lruihao.cn/images/avatar.jpg - url: https://lruihao.cn - description: Lruihao's Note ","date":"2025-04-12","objectID":"/posts/hugo-fixit/3c94d6e/:2:1","tags":["建站笔记"],"title":"Hugo 自定义页面","uri":"/posts/hugo-fixit/3c94d6e/"},{"categories":["建站笔记"],"content":"定义站点页面的模板 在layouts/page/目录下创建websites.html，内容参考layouts/page/friends.html。这里在friends.html页面模板上做了一些针对性的修改。 {{- define \"title\" -}} {{- cond (.Param \"capitalizeTitles\") (title .Title) .Title -}} {{- if .Site.Params.withSiteTitle }} {{ .Site.Params.titleDelimiter }} {{ .Site.Title }}{{- end -}} {{- end -}} {{- define \"content\" -}} {{- $params := partial \"function/params.html\" -}} \u003carticle class=\"page single special websites\"\u003e \u003cdiv class=\"header\"\u003e {{- /* Title */ -}} \u003ch1 class=\"single-title animate__animated animate__pulse animate__faster\"\u003e{{- cond (.Param \"capitalizeTitles\") (title .Title) .Title -}}\u003c/h1\u003e {{- /* Subtitle */ -}} {{- with $params.subtitle -}}\u003cp class=\"single-subtitle animate__animated animate__fadeIn\"\u003e{{ . | $.RenderString }} \u003c/p\u003e{{- end -}} \u003c/div\u003e {{- /* website links grouped by category */ -}} \u003cscript src=\"//at.alicdn.com/t/font_578712_g26jo2kbzd5qm2t9.js\" async defer\u003e\u003c/script\u003e {{- $websites := .Site.Data.websites -}} {{- $categories := dict -}} {{- range $website := $websites -}} {{- $category := $website.category | default \"未分类\" -}} {{- $items := index $categories $category | default slice -}} {{- $items = $items | append $website -}} {{- $categories = merge $categories (dict $category $items) -}} {{- end -}} {{- /* 获取所有分类并按权重排序 */ -}} {{- $sortedCategories := slice -}} {{- range $category, $items := $categories -}} {{- $weight := 9999 -}} {{- /* 默认权重 */ -}} {{- range $items -}} {{- if isset . \"category_weight\" -}} {{- $weight = .category_weight -}} {{- end -}} {{- end -}} {{- $sortedCategories = $sortedCategories | append (dict \"name\" $category \"items\" $items \"weight\" $weight) -}} {{- end -}} {{- $sortedCategories = sort $sortedCategories \"weight\" \"asc\" -}} {{- /* 渲染排序后的分类 */ -}} {{- range $category := $sortedCategories -}} \u003ch2 class=\"website-category\"\u003e{{ $category.name }}\u003c/h2\u003e \u003cdiv class=\"website-links\"\u003e {{ range $index, $website := $category.items }} \u003ca class=\"website\" title=\"{{ $website.description }}\" href=\"{{ $website.url | safeURL }}\" rel=\"external noopener\" target=\"_blank\"\u003e {{ if $website.avatar }} {{- dict \"Src\" $website.avatar \"Alt\" $website.nickname \"Title\" $website.description \"Class\" \"website-avatar\" | partial \"plugin/image.html\" -}} {{ else }} \u003csvg class=\"website-avatar\" aria-hidden=\"true\"\u003e \u003cuse xlink:href=\"#icon-{{ add 1 $index }}\"\u003e\u003c/use\u003e \u003c/svg\u003e {{ end }} \u003cdiv class=\"website-info\"\u003e \u003cspan class=\"website-nickname\" title=\"{{ $website.nickname }}\"\u003e{{ $website.nickname }}\u003c/span\u003e \u003cspan class=\"website-description\" title=\"{{ $website.description }}\"\u003e{{ $website.description }}\u003c/span\u003e \u003c/div\u003e \u003c/a\u003e {{ end }} \u003c/div\u003e {{- end -}} {{- /* Content */ -}} \u003cdiv class=\"content\" id=\"content\"\u003e {{- dict \"Content\" .Content \"Ruby\" $params.ruby \"Fraction\" $params.fraction \"Fontawesome\" $params.fontawesome | partial \"function/content.html\" | safeHTML -}} \u003c/div\u003e {{- /* Comment */ -}} {{- partial \"single/comment.html\" . -}} \u003c/article\u003e {{- end -}} 在data/目录下面创建websites.yml，这是和模板对应的站点配置文件。 # 站点信息 - nickname: Hugo avatar: https://gohugo.io/favicon.ico url: https://gohugo.io/ description: | Hugo is one of the most popular open-source static site generators. With its amazing speed and flexibility, Hugo makes building websites fun again. category: 本站技术支持 category_weight: 1 - nickname: FixIt avatar: https://fixit.lruihao.cn/favicon.ico url: https://fixit.lruihao.cn/zh-cn/ description: 一个简洁、优雅且高效的 Hugo 主题 category: 本站技术支持 category_weight: 1 - nickname: Font Awesome avatar: https://fontawesome.com/favicon.ico url: https://fontawesome.com/icons description: 一个包含很多icon的开源图标库 category: 工具类 category_weight: 2 ","date":"2025-04-12","objectID":"/posts/hugo-fixit/3c94d6e/:2:2","tags":["建站笔记"],"title":"Hugo 自定义页面","uri":"/posts/hugo-fixit/3c94d6e/"},{"categories":["建站笔记"],"content":"调整站点页面样式 在assets/css/_custom.scss文件中添加以下代码： .website { display: flex; align-items: center; } .website-info { display: flex; flex-direction: column; margin-left: 10px; } .website-description { font-size: 0.8em; color: #666; } .website-links { display: flex; flex-wrap: wrap; // 允许换行 gap: 20px; // 卡片间距 margin-bottom: 30px; // 分类间间距 } .website { display: flex; align-items: center; height: 80px; min-height: 80px; width: 250px; // 固定卡片宽度 overflow: hidden; flex: 0 0 auto; max-width: none; box-sizing: border-box; padding: 12px; border-radius: 8px; background: rgba(0, 0, 0, 0.02); transition: all 0.2s ease; \u0026:hover { background: rgba(0, 0, 0, 0.05); } } .website-avatar { width: 60px; height: 60px; object-fit: cover; flex-shrink: 0; } .website-info { display: flex; flex-direction: column; justify-content: center; // 保持垂直居中 height: 100%; margin-left: 12px; overflow: hidden; width: calc(100% - 72px); } .website-nickname { font-weight: bold; margin-bottom: 6px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; } .website-description { display: -webkit-box; -webkit-line-clamp: 1; // 限制显示1行 -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; font-size: 0.8em; color: #666; line-height: 1.4; max-height: 3.6em; // 3行高度 } ","date":"2025-04-12","objectID":"/posts/hugo-fixit/3c94d6e/:2:3","tags":["建站笔记"],"title":"Hugo 自定义页面","uri":"/posts/hugo-fixit/3c94d6e/"},{"categories":["建站笔记"],"content":"创建站点链接页面 创建一个站点链接页面，在 Front matter 中设置layout: websites，然后运行hugo命令生成页面： hugo new content websites/index.md hugo server -D ","date":"2025-04-12","objectID":"/posts/hugo-fixit/3c94d6e/:2:4","tags":["建站笔记"],"title":"Hugo 自定义页面","uri":"/posts/hugo-fixit/3c94d6e/"},{"categories":null,"content":"beneliu's websites","date":"2025-04-11","objectID":"/websites/","tags":null,"title":"站点","uri":"/websites/"},{"categories":null,"content":"示例信息 - nickname: 网站名称 avatar: 网站logo url: 网站地址 description: 网站描述 ","date":"2025-04-11","objectID":"/websites/:1:0","tags":null,"title":"站点","uri":"/websites/"},{"categories":null,"content":"beneliu's friends","date":"2025-04-06","objectID":"/friends/","tags":null,"title":"友链","uri":"/friends/"},{"categories":null,"content":"友链格式 - nickname: 字节飞鸿 - avatar: https://beneliu.github.io/images/avatar.png - url: https://beneliu.github.io/ - description: beneliu's blog ","date":"2025-04-06","objectID":"/friends/:1:0","tags":null,"title":"友链","uri":"/friends/"},{"categories":null,"content":"添加友链要求 按以下格式在评论区留言： ```yaml - nickname: \u003cyour nickname\u003e avatar: \u003cyour avatar\u003e url: \u003cyour site link\u003e description: \u003cdescription of your site\u003e ``` Notice 尊重他人劳动成果，博客内容转载不加出处的，或恶意行为的网站，会清除友链。 ","date":"2025-04-06","objectID":"/friends/:2:0","tags":null,"title":"友链","uri":"/friends/"},{"categories":["建站笔记"],"content":" 内容简介 记录FixIt主题美化的操作步骤。 ","date":"2025-04-06","objectID":"/posts/hugo-fixit/a9f08a3/:0:0","tags":["建站笔记"],"title":"Fixit-主题美化","uri":"/posts/hugo-fixit/a9f08a3/"},{"categories":["建站笔记"],"content":"一、自定义css ","date":"2025-04-06","objectID":"/posts/hugo-fixit/a9f08a3/:1:0","tags":["建站笔记"],"title":"Fixit-主题美化","uri":"/posts/hugo-fixit/a9f08a3/"},{"categories":["建站笔记"],"content":"1.1 自定义字体 在站点项目根目录下面，在/assets/css/_custom.scss中添加以下代码即可自定义字体。推荐在中文网字计划中挑选自己喜欢的字体。 // 引入字体 https://chinese-font.netlify.app/zh-cn/cdn/ @import url('https://chinese-fonts-cdn.deno.dev/packages/lxgwwenkai/dist/LXGWWenKai-Light/result.css'); // 自定义字体 html,body { font-family: \"LXGW WenKai Light\"; font-weight: normal; font-size: 1rem; } ","date":"2025-04-06","objectID":"/posts/hugo-fixit/a9f08a3/:1:1","tags":["建站笔记"],"title":"Fixit-主题美化","uri":"/posts/hugo-fixit/a9f08a3/"},{"categories":["建站笔记"],"content":"1.2 自定义文章网格背景 在/assets/css/_custom.scss文件中添加如下代码： /** 添加网格背景 */ .single { .single-subtitle { color: #57606a; } .content { background-image: linear-gradient(90deg, rgba(60, 10, 30, .04) 3%, transparent 0), linear-gradient(1turn, rgba(60, 10, 30, .04) 3%, transparent 0); background-size: 20px 20px; background-position: center; [data-theme='dark'] \u0026 { background-image: linear-gradient(90deg, rgba(195, 245, 215, .04) 3%, transparent 0), linear-gradient(1turn, rgba(195, 245, 215, .04) 3%, transparent 0); } } } ","date":"2025-04-06","objectID":"/posts/hugo-fixit/a9f08a3/:1:2","tags":["建站笔记"],"title":"Fixit-主题美化","uri":"/posts/hugo-fixit/a9f08a3/"},{"categories":["建站笔记"],"content":"二、自定义模板 ","date":"2025-04-06","objectID":"/posts/hugo-fixit/a9f08a3/:2:0","tags":["建站笔记"],"title":"Fixit-主题美化","uri":"/posts/hugo-fixit/a9f08a3/"},{"categories":["建站笔记"],"content":"2.1 自定义文章页面侧边目录模板 在站点项目根目录下面，/layouts/partials/文件夹下创建custom文件夹，可以用来存储自定义模板。Hugo有自带的toc模板, 可以通过{{.Content}}引入这个模板, 具体可以看官方使用教程。在使用过程发现有多级标题时，侧边目录标号顺序不能实现1.1、1.1.1的形式。索性想自己定义一个toc模板使用，需要1.1、1.1.1形式的侧边目录编号时，自己在md文档中添加即可。/layouts/partials/custom/toc.html： {{- /* 自定义toc目录 */ -}} {{ $headers := findRE \"\u003ch[1-4].*?\u003e(.|\\n])+?\u003c/h[1-4]\u003e\" .Content }} \u003c!-- at least one header to link to --\u003e {{ if ge (len $headers) 1 }} {{ $h1_n := len (findRE \"(.|\\n])+?\" .Content) }} {{ $re := (cond (eq $h1_n 0) \"\u003ch[2-4]\" \"\u003ch[1-4]\") }} {{ $renum := (cond (eq $h1_n 0) \"[2-4]\" \"[1-4]\") }} \u003c!--Scrollspy--\u003e \u003cdiv class=\"toc\"\u003e \u003cdiv class=\"page-header\"\u003e\u003cstrong\u003e- CATALOG -\u003c/strong\u003e\u003c/div\u003e \u003cdiv id=\"page-scrollspy\" class=\"toc-nav\"\u003e {{ range $headers }} {{ $header := . }} {{ range first 1 (findRE $re $header 1) }} {{ range findRE $renum . 1 }} {{ $next_heading := (cond (eq $h1_n 0) (sub (int .) 1 ) (int . ) ) }} {{ range seq $next_heading }} \u003cul class=\"nav\"\u003e {{end}} {{ $anchorId := (replaceRE \".* id=\\\"(.*?)\\\".*\" \"$1\" $header ) }} \u003cli class=\"nav-item\"\u003e \u003ca class=\"nav-link text-left\" href=\"#{{ $anchorId }}\"\u003e {{ $header | plainify | htmlUnescape }} \u003c/a\u003e \u003c/li\u003e \u003c!-- close list --\u003e {{ range seq $next_heading }} \u003c/ul\u003e {{ end }} {{ end }} {{ end }} {{ end }} \u003c/div\u003e \u003c/div\u003e \u003c!--Scrollspy--\u003e {{ end }} ","date":"2025-04-06","objectID":"/posts/hugo-fixit/a9f08a3/:2:1","tags":["建站笔记"],"title":"Fixit-主题美化","uri":"/posts/hugo-fixit/a9f08a3/"},{"categories":["建站笔记"],"content":"三、自定义js 在站点项目根目录下面，在/assets/js/custom.js中添加自定义的js代码。 ","date":"2025-04-06","objectID":"/posts/hugo-fixit/a9f08a3/:3:0","tags":["建站笔记"],"title":"Fixit-主题美化","uri":"/posts/hugo-fixit/a9f08a3/"},{"categories":["建站笔记"],"content":"3.1 设置网站title动态 设置网站title动态，当网页失去焦点时改变网页title，引起用户注意。 // 动态设置网站title，当网页失去焦点时改变网页title，引起用户注意。 document.addEventListener('DOMContentLoaded', function () { // 调试日志 // console.log('[动态标题] 脚本已加载'); const originTitle = document.title; let titleTimer; function updateTitle(newTitle, duration = 2000) { document.title = newTitle; if (duration \u003e 0) { clearTimeout(titleTimer); titleTimer = setTimeout(() =\u003e { document.title = originTitle; }, duration); } } // 页面可见性变化 document.addEventListener('visibilitychange', function () { // console.log('[动态标题] 可见性变化:', document.hidden); if (document.hidden) { updateTitle('👀 别走呀～ ', 0); } else { updateTitle('🎉 欢迎回来！ '); } }); // 窗口焦点变化 window.addEventListener('blur', function () { // console.log('[动态标题] 窗口失去焦点'); updateTitle('💤 我在等你哦～ ', 0); }); window.addEventListener('focus', function () { // console.log('[动态标题] 窗口获得焦点'); updateTitle('😍 你回来啦！ '); }); // console.log('[动态标题] 初始化完成'); }); ","date":"2025-04-06","objectID":"/posts/hugo-fixit/a9f08a3/:3:1","tags":["建站笔记"],"title":"Fixit-主题美化","uri":"/posts/hugo-fixit/a9f08a3/"},{"categories":["建站笔记"],"content":"四、设置Github提交记录贪吃蛇动画 分两步完成： 先通过 GitHub Action Platane/snk 生成 svg 动画并上传到 GitHub 仓库； 自定义博客首页头像 css，将贪食蛇动画 svg 作为首页头像的背景图片； ","date":"2025-04-06","objectID":"/posts/hugo-fixit/a9f08a3/:4:0","tags":["建站笔记"],"title":"Fixit-主题美化","uri":"/posts/hugo-fixit/a9f08a3/"},{"categories":["建站笔记"],"content":"4.1 贪吃蛇动画生成 找一个公开仓库添加 GitHub Action 工作流，第一次提交后可手动执行，定时任务等效东八区时间每天早上 5:30 和下午 17:30 执行，以保证贪食蛇动画中的提交记录更新。 name: Generate Snake Animation on: workflow_dispatch: schedule: # equal UTC/GMT+8 \"30 5,17 * * *\" - cron: \"30 9,21 * * *\" jobs: generate: permissions: contents: write runs-on: ubuntu-latest timeout-minutes: 10 steps: # https://github.com/Platane/snk - name: generate github-contribution-grid-snake.svg uses: Platane/snk/svg-only@v3 with: github_user_name: ${{ github.repository_owner }} outputs: | dist/github-contribution-grid-snake.svg dist/github-contribution-grid-snake-dark.svg?palette=github-dark # push the content of \u003cbuild_dir\u003e to a branch # the content will be available at https://raw.githubusercontent.com/\u003cgithub_user\u003e/\u003crepository\u003e/\u003ctarget_branch\u003e/\u003cfile\u003e - name: push github-contribution-grid-snake.svg to the output branch uses: crazy-max/ghaction-github-pages@v4 with: target_branch: output build_dir: dist env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} 任务执行后，在仓库的 output 分支可以看到生成的 svg 文件： ","date":"2025-04-06","objectID":"/posts/hugo-fixit/a9f08a3/:4:1","tags":["建站笔记"],"title":"Fixit-主题美化","uri":"/posts/hugo-fixit/a9f08a3/"},{"categories":["建站笔记"],"content":"4.2 自定义首页头像css 通过浏览器控制台定位头像元素： 然后添加对应 css 样式： // assets/css/_custom.scss .home .home-profile .home-avatar { background-size: 100% 100%; padding: 1rem; background-repeat: no-repeat; background-position: center top; background-image: url(https://raw.githubusercontent.com/beneliu/blog-resource/output/github-contribution-grid-snake.svg); [data-theme='dark'] \u0026 { background-image: url(https://raw.githubusercontent.com/beneliu/blog-resource/output/github-contribution-grid-snake-dark.svg); } } 因为background-image地址国内有时无法正常显示，可以用jsdelivr加速。将地址替换成https://cdn.jsdelivr.net/gh/beneliu/blog-resource@output/github-contribution-grid-snake.svg。jsdelivr的具体使用方法可以看jsdelivr。 ","date":"2025-04-06","objectID":"/posts/hugo-fixit/a9f08a3/:4:2","tags":["建站笔记"],"title":"Fixit-主题美化","uri":"/posts/hugo-fixit/a9f08a3/"},{"categories":["建站笔记"],"content":"五、添加友链 先创建友情链接页面： hugo new content friends/index.md 在 Front matter 中设置layout: friends，并在yourSite/data/目录下创建friends.yml，其内容格式如下： # 朋友/站点信息例子 - nickname: 朋友名字 avatar: 朋友头像 url: 站点链接 description: 对朋友或其站点的说明 然后就可以将生成的友链页面添加到主页菜单栏了。 参考资料： 内容管理概述 | FixiIt 开放的自定义块 | FixiIt Fixit-主题美化记录 jsdelivr Hugo添加文章目录toc ","date":"2025-04-06","objectID":"/posts/hugo-fixit/a9f08a3/:5:0","tags":["建站笔记"],"title":"Fixit-主题美化","uri":"/posts/hugo-fixit/a9f08a3/"},{"categories":["建站笔记"],"content":" 内容简介 简单介绍 Hugo 的一些核心概念和原理，包括核心工作流程、构建过程解析、目录结构、如何安装等。 ","date":"2025-04-03","objectID":"/posts/hugo-fixit/738f0f6/:0:0","tags":["建站笔记"],"title":"Hugo学习","uri":"/posts/hugo-fixit/738f0f6/"},{"categories":["建站笔记"],"content":"Hugo简介 Hugo是一个用 Go 语言编写的开源静态网站生成器，具有以下核心特点： ⚡ 极速构建：平均构建速度 \u003c 1秒/千页 📂 内容优先：支持 Markdown 格式内容管理 🎨 主题生态：丰富的主题库 🖥️ 跨平台：支持 Windows/macOS/Linux 🌍 多语言：内置国际化（i18n）支持 典型应用场景： 个人/技术博客 项目文档网站 企业官网 作品集展示 ","date":"2025-04-03","objectID":"/posts/hugo-fixit/738f0f6/:1:0","tags":["建站笔记"],"title":"Hugo学习","uri":"/posts/hugo-fixit/738f0f6/"},{"categories":["建站笔记"],"content":"Hugo实现博客建站的原理 ","date":"2025-04-03","objectID":"/posts/hugo-fixit/738f0f6/:2:0","tags":["建站笔记"],"title":"Hugo学习","uri":"/posts/hugo-fixit/738f0f6/"},{"categories":["建站笔记"],"content":"核心工作流程 graph LR A[Markdown 内容] --\u003e B[Hugo 引擎] C[模板文件] --\u003e B D[静态资源] --\u003e B B --\u003e E[静态HTML网站] graph LR A[Markdown 内容] --\u003e B[Hugo 引擎] C[模板文件] --\u003e B D[静态资源] --\u003e B B --\u003e E[静态HTML网站] 构建过程： 读取配置文件确定构建参数 解析 Markdown 内容为结构化数据 将内容数据注入模板文件 生成静态 HTML/CSS/JS 文件 输出到 /public 目录 ","date":"2025-04-03","objectID":"/posts/hugo-fixit/738f0f6/:2:1","tags":["建站笔记"],"title":"Hugo学习","uri":"/posts/hugo-fixit/738f0f6/"},{"categories":["建站笔记"],"content":"目录结构 每个 Hugo 项目都是一个目录，其中的子目录贡献于站点的内容、结构、行为和呈现。在创建新站点时，Hugo 会生成一个项目骨架。例如，运行以下命令： hugo new site my-site 会创建以下目录结构： my-site/ ├── archetypes/ │ └── default.md ├── assets/ ├── content/ ├── data/ ├── i18n/ ├── layouts/ ├── static/ ├── themes/ └── hugo.toml \u003c-- 站点配置 根据需要，也可以将站点配置组织到子目录中： my-site/ ├── archetypes/ │ └── default.md ├── assets/ ├── config/ \u003c-- 站点配置 │ └── _default/ │ └── hugo.toml ├── content/ ├── data/ ├── i18n/ ├── layouts/ ├── static/ └── themes/ 本站点就是采用的这种方式，将配置文件放置在 config 目录下，以 _default 为子目录，以 hugo.toml 为文件名。Hugo默认的站点目录结构如下： archetypes：原型目录，用于定义各种类型的内容模板。原型匹配顺序是优先本站点内，其次再到主题内查找。 assets：资产目录，用于放置 CSS，JavaScript 等全局资源库。 config：配置文件目录，主配置文件 hugo.yaml，支持多文件配置、多环境配置。 content：内容目录，用于放置文章、分类、标签等内容页面。 data：数据目录，用于存取自定义配置数据。 i18n：国际化目录，用于存放多语言配置文件和博客页面。 layouts：布局目录，用于存放模板文件。 public：部署目录，用于存放 Hugo 构建的静态站点文件。 resources：资源目录，包含 Hugo 资产构建流水线产生的可缓存文件，如 CSS、图片等。 static：静态资源目录，用于放置静态资源文件，如图片、CSS、JavaScript 等。该目录下的文件会被直接拷贝到站点部署目录。 themes：主题目录，用于存放主题文件。 具体每个目录的作用可以参考官方文档：目录结构 | Hugo官方文档 ","date":"2025-04-03","objectID":"/posts/hugo-fixit/738f0f6/:2:2","tags":["建站笔记"],"title":"Hugo学习","uri":"/posts/hugo-fixit/738f0f6/"},{"categories":["建站笔记"],"content":"Hugo安装与常用命令 ","date":"2025-04-03","objectID":"/posts/hugo-fixit/738f0f6/:3:0","tags":["建站笔记"],"title":"Hugo学习","uri":"/posts/hugo-fixit/738f0f6/"},{"categories":["建站笔记"],"content":"Hugo安装 macOS: brew install hugo Linux: snap install hugo Windows: choco install hugo 博主用的是Windows，但是没有选择choco进行安装，而是直接下载二进制zip包进行安装，因为可以装最新版，也更方便控制安装路径。hugo命令安装包下载地址：Hugo Releases | GitHub。下载后解压，将解压后的文件夹添加到环境变量中，就可以使用hugo命令了。至于怎么添加环境变量，这里就不赘述了。 ","date":"2025-04-03","objectID":"/posts/hugo-fixit/738f0f6/:3:1","tags":["建站笔记"],"title":"Hugo学习","uri":"/posts/hugo-fixit/738f0f6/"},{"categories":["建站笔记"],"content":"hugo命令行 hugo help hugo is the main command, used to build your Hugo site. Hugo is a Fast and Flexible Static Site Generator built with love by spf13 and friends in Go. Complete documentation is available at https://gohugo.io/. Usage: hugo [flags] hugo [command] Available Commands: build Build your site completion Generate the autocompletion script for the specified shell config Display site configuration convert Convert front matter to another format env Display version and environment info gen Generate documentation and syntax highlighting styles help Help about any command import Import a site from another system list List content mod Manage modules new Create new content server Start the embedded web server version Display version Flags: -b, --baseURL string hostname (and path) to the root, e.g. https://spf13.com/ -D, --buildDrafts include content marked as draft -E, --buildExpired include expired content -F, --buildFuture include content with publishdate in the future --cacheDir string filesystem path to cache directory --cleanDestinationDir remove files from destination not found in static directories --clock string set the clock used by Hugo, e.g. --clock 2021-11-06T22:30:00.00+09:00 --config string config file (default is hugo.yaml|json|toml) --configDir string config dir (default \"config\") -c, --contentDir string filesystem path to content directory -d, --destination string filesystem path to write files to --disableKinds strings disable different kind of pages (home, RSS etc.) --enableGitInfo add Git revision, date, author, and CODEOWNERS info to the pages -e, --environment string build environment --forceSyncStatic copy all files when static is changed. --gc enable to run some cleanup tasks (remove unused cache files) after the build -h, --help help for hugo -h, --help help for hugo --ignoreCache ignores the cache directory --ignoreVendorPaths string ignores any _vendor for module paths matching the given Glob pattern -l, --layoutDir string filesystem path to layout directory --logLevel string log level (debug|info|warn|error) --minify minify any supported output format (HTML, XML etc.) --minify minify any supported output format (HTML, XML etc.) --noBuildLock don't create .hugo_build.lock file --noChmod don't sync permission mode of files --noTimes don't sync modification time of files --noBuildLock don't create .hugo_build.lock file --noChmod don't sync permission mode of files --noTimes don't sync modification time of files --panicOnWarning panic on first WARNING log --panicOnWarning panic on first WARNING log --poll string set this to a poll interval, e.g --poll 700ms, to use a poll based approach to watch for file system changes --poll string set this to a poll interval, e.g --poll 700ms, to use a poll based approach to watch for file system changes --printI18nWarnings print missing translations --printI18nWarnings print missing translations --printMemoryUsage print memory usage to screen at intervals --printMemoryUsage print memory usage to screen at intervals --printPathWarnings print warnings on duplicate target paths etc. --printPathWarnings print warnings on duplicate target paths etc. --printUnusedTemplates print warnings on unused templates. --printUnusedTemplates print warnings on unused templates. --quiet build in quiet mode --quiet build in quiet mode --renderSegments strings named segments to render (configured in the segments config) --renderSegments strings named segments to render (configured in the segments config) -M, --renderToMemory render to memory (mostly useful when running the server) -M, --renderToMemory render to memory (mostly useful when running the server) -s, --source string filesystem path to read files relative from --templateMetrics display metrics about template executions -s, --source string filesystem path to read files relative from --templateMetrics display metrics about template executions --templateMetricsHints calculate some improvement hints when combined with --templateMe","date":"2025-04-03","objectID":"/posts/hugo-fixit/738f0f6/:3:2","tags":["建站笔记"],"title":"Hugo学习","uri":"/posts/hugo-fixit/738f0f6/"},{"categories":["Demo"],"content":"欢迎来到我的博客空间 这是我用Hugo+FixIt主题创作的的第一篇博客。 ","date":"2025-04-02","objectID":"/posts/38114d4/:1:0","tags":["Demo"],"title":"我的第一篇博客","uri":"/posts/38114d4/"}]